from db.mongo_db import db
from datetime import datetime



# For logging
import logging
logger = logging.getLogger(__name__)

async def upload_list_on_mongodb(patient_id: str, call_id, new_chats: list) -> int:
    """
    Appends new chat items to a dynamic field (named by call_id) in the document 
    associated with a given patient_id.
    
    If a document with the provided patient_id doesn't exist, a new document is created 
    with:
      - A random _id automatically generated by MongoDB (an ObjectId)
      - A "patient_id" attribute set to the provided patient_id
    
    Args:
        patient_id (str): The patient identifier (stored as an attribute, not as _id).
        call_id: The identifier used as the field name to store chats.
        new_chats (list): A list of new chat items to append.
        
    Returns:
        int: The number of modified documents.
    """
    try:
        # Filter using patient_id (do not convert it to an ObjectId)
        filter_query = {"patient_id": patient_id}
        
        # Update query: push new chats into the dynamic field, and if the document doesn't exist,
        # set the patient_id attribute.
        update_query = {
            "$push": {str(call_id): {"$each": new_chats}},
            "$setOnInsert": {"patient_id": patient_id}
        }
    
        # Use upsert=True so that a new document is created if none exists.
        result = await db.chats.update_one(filter_query, update_query, upsert=True)
        logger.info("Data uploaded successfully for patient_id: %s, call_id: %s", patient_id, str(call_id))
        return result.modified_count
    except Exception as e:
        logger.error("Error in upload_on_mongodb: %s", str(e))
        raise



async def upload_on_mongodb(patient_id: str, call_id: str, data_to_upload: dict) -> int:
    """
    Updates (or creates) a document for the given patient. The document will have:
      - _id: randomly generated ObjectId (by MongoDB)
      - patient_id: the given patient_id
      - carehome_id: the given carehome_id (from data_to_upload)
      - calls: an array in which each element is an object with:
            {
                "call_id": <call_id>,
                "human_messages": <messages>,
                "sentiment_analysis": <sentiment_analysis>
            }
    
    If a document for the given patient_id exists, the function pushes a new call object onto the calls array.
    Otherwise, it creates a new document with the provided fields.
    
    Args:
        patient_id (str): The patientâ€™s identifier.
        call_id (str): The call identifier.
        data_to_upload (dict): Should contain:
            - "human_messages": the messages text,
            - "sentiment_analysis": the sentiment analysis,
            - "carehome_id": the care home identifier.
    
    Returns:
        int: The number of documents modified.
    """
    try:
        # Filter: find document by patient_id
        filter_query = {"patient_id": patient_id}
        
        # Build the call object to insert
        new_call = {
            "call_id": call_id,
            "human_messages": data_to_upload.get("human_messages"),
            "sentiment_analysis": data_to_upload.get("sentiment_analysis"),
            "call_time": datetime.utcnow()
        }
        
        # Update: push new call into the 'calls' array.
        # $setOnInsert sets patient_id and carehome_id if the document is created.
        update_query = {
            "$push": {"calls": new_call},
            "$setOnInsert": {
            "patient_id": patient_id,
            "carehome_id": data_to_upload.get("carehome_id")}}

    
        # Use upsert=True to create a new document if one does not exist.
        result = await db.chats.update_one(filter_query, update_query, upsert=True)
        logger.info("Document updated for patient_id: %s with call_id: %s", patient_id, call_id)
        return result.modified_count
    except Exception as e:
        print("Error in mongodb service is: ", str(e))
        logger.error("Error in upload_on_mongodb: %s", str(e))
        raise